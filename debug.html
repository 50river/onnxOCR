<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug - é ˜åæ›¸OCR</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .error { color: red; background: #ffe6e6; padding: 10px; margin: 10px 0; }
        .success { color: green; background: #e6ffe6; padding: 10px; margin: 10px 0; }
        .info { color: blue; background: #e6f3ff; padding: 10px; margin: 10px 0; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>é ˜åæ›¸OCR - ãƒ‡ãƒãƒƒã‚°æƒ…å ±</h1>
    <div id="debug-output"></div>
    
    <script>
        const debugOutput = document.getElementById('debug-output');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = message;
            debugOutput.appendChild(div);
            console.log(`[${type.toUpperCase()}]`, message);
        }
        
        async function runDiagnostics() {
            log('ğŸ” è¨ºæ–­ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
            
            // 0. GitHub Pagesç’°å¢ƒã®ç¢ºèª
            log('0. GitHub Pagesç’°å¢ƒç¢ºèª', 'info');
            const isGitHubPages = window.location.hostname.includes('github.io') || 
                                 window.location.hostname.includes('github.com');
            const forceFallback = window.FORCE_TESSERACT_FALLBACK || window.GITHUB_PAGES_MODE;
            
            log(`ãƒ›ã‚¹ãƒˆå: ${window.location.hostname}`, 'info');
            log(`GitHub Pagesç’°å¢ƒ: ${isGitHubPages ? 'âœ… ã¯ã„' : 'âŒ ã„ã„ãˆ'}`, isGitHubPages ? 'success' : 'info');
            log(`ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰: ${forceFallback ? 'âœ… æœ‰åŠ¹' : 'âŒ ç„¡åŠ¹'}`, forceFallback ? 'success' : 'info');
            
            // 1. åŸºæœ¬çš„ãªAPIç¢ºèª
            log('1. åŸºæœ¬APIç¢ºèª', 'info');
            
            if (typeof fetch !== 'undefined') {
                log('âœ… fetch APIåˆ©ç”¨å¯èƒ½', 'success');
            } else {
                log('âŒ fetch APIåˆ©ç”¨ä¸å¯', 'error');
            }
            
            if (typeof Worker !== 'undefined') {
                log('âœ… Web Workeråˆ©ç”¨å¯èƒ½', 'success');
            } else {
                log('âŒ Web Workeråˆ©ç”¨ä¸å¯', 'error');
            }
            
            if (typeof indexedDB !== 'undefined') {
                log('âœ… IndexedDBåˆ©ç”¨å¯èƒ½', 'success');
            } else {
                log('âŒ IndexedDBåˆ©ç”¨ä¸å¯', 'error');
            }
            
            // 2. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
            log('2. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª', 'info');
            
            const libraries = [
                'libs/ort.min.js',
                'libs/tesseract.min.js',
                'libs/opencv.js',
                'libs/jszip.min.js'
            ];
            
            for (const lib of libraries) {
                try {
                    const response = await fetch(lib, { method: 'HEAD' });
                    if (response.ok) {
                        log(`âœ… ${lib} (${response.headers.get('content-length')} bytes)`, 'success');
                    } else {
                        log(`âŒ ${lib} - HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ ${lib} - ${error.message}`, 'error');
                }
            }
            
            // 3. ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
            log('3. ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª', 'info');
            
            const models = [
                'models/text_det.onnx',
                'models/text_rec_jp.onnx',
                'models/text_angle.onnx',
                'models/charset_jp.txt'
            ];
            
            for (const model of models) {
                try {
                    const response = await fetch(model, { method: 'HEAD' });
                    if (response.ok) {
                        const size = response.headers.get('content-length');
                        if (parseInt(size) < 1000) {
                            log(`âš ï¸ ${model} (${size} bytes) - ã‚µã‚¤ã‚ºãŒå°ã•ã™ãã¾ã™`, 'error');
                        } else {
                            log(`âœ… ${model} (${size} bytes)`, 'success');
                        }
                    } else {
                        log(`âŒ ${model} - HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ ${model} - ${error.message}`, 'error');
                }
            }
            
            // 4. JSãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
            log('4. JSãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª', 'info');
            
            const jsFiles = [
                'js/app.js',
                'js/ocr-engine.js',
                'js/field-extractor.js',
                'js/ocr-worker.js'
            ];
            
            for (const jsFile of jsFiles) {
                try {
                    const response = await fetch(jsFile, { method: 'HEAD' });
                    if (response.ok) {
                        log(`âœ… ${jsFile} (${response.headers.get('content-length')} bytes)`, 'success');
                    } else {
                        log(`âŒ ${jsFile} - HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ ${jsFile} - ${error.message}`, 'error');
                }
            }
            
            // 5. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ
            log('5. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ', 'info');
            
            try {
                // ONNX Runtime Web
                const ortScript = document.createElement('script');
                ortScript.src = 'libs/ort.min.js';
                ortScript.onload = () => {
                    if (typeof ort !== 'undefined') {
                        log('âœ… ONNX Runtime Webèª­ã¿è¾¼ã¿æˆåŠŸ', 'success');
                        log(`ONNX Runtime ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${ort.version || 'unknown'}`, 'info');
                    } else {
                        log('âŒ ONNX Runtime Webèª­ã¿è¾¼ã¿å¤±æ•—', 'error');
                    }
                };
                ortScript.onerror = () => {
                    log('âŒ ONNX Runtime Webèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', 'error');
                };
                document.head.appendChild(ortScript);
                
            } catch (error) {
                log(`âŒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
            
            // 6. Service Workerç¢ºèª
            log('6. Service Workerç¢ºèª', 'info');
            
            if ('serviceWorker' in navigator) {
                log('âœ… Service Worker APIåˆ©ç”¨å¯èƒ½', 'success');
                
                try {
                    const registration = await navigator.serviceWorker.getRegistration();
                    if (registration) {
                        log(`âœ… Service Workerç™»éŒ²æ¸ˆã¿: ${registration.scope}`, 'success');
                        log(`çŠ¶æ…‹: ${registration.active ? registration.active.state : 'inactive'}`, 'info');
                    } else {
                        log('âš ï¸ Service Workeræœªç™»éŒ²', 'error');
                    }
                } catch (error) {
                    log(`âŒ Service Workerç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            } else {
                log('âŒ Service Worker APIåˆ©ç”¨ä¸å¯', 'error');
            }
            
            // 7. ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ç›£è¦–
            log('7. ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ç›£è¦–é–‹å§‹', 'info');
            
            window.addEventListener('error', (event) => {
                log(`âŒ JavaScript Error: ${event.message} at ${event.filename}:${event.lineno}`, 'error');
            });
            
            window.addEventListener('unhandledrejection', (event) => {
                log(`âŒ Unhandled Promise Rejection: ${event.reason}`, 'error');
            });
            
            log('ğŸ¯ è¨ºæ–­å®Œäº†', 'info');
        }
        
        // è¨ºæ–­å®Ÿè¡Œ
        runDiagnostics().catch(error => {
            log(`âŒ è¨ºæ–­ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
        });
    </script>
</body>
</html>