<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .warning { background-color: #fff3cd; color: #856404; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto; }
        button { 
            background: #007bff; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 5px; 
            cursor: pointer; 
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .file-info { margin: 5px 0; font-family: monospace; }
    </style>
</head>
<body>
    <h1>ğŸ¤– ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®ãƒ†ã‚¹ãƒˆ</h1>
    <p>ã“ã®ãƒ†ã‚¹ãƒˆã¯ã€å¿…è¦ãªONNXãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ãé…ç½®ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚</p>
    
    <button onclick="runTests()">ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
    <button onclick="clearResults()">çµæœã‚¯ãƒªã‚¢</button>
    
    <div id="results"></div>

    <script src="../models/validate-models.js"></script>
    <script>
        const resultsDiv = document.getElementById('results');
        
        function clearResults() {
            resultsDiv.innerHTML = '';
        }
        
        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = message;
            resultsDiv.appendChild(div);
        }
        
        async function runTests() {
            clearResults();
            addResult('ğŸ” ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹ã—ã¾ã™...', 'info');
            
            try {
                // Test 1: Check if all required files exist
                addResult('<h3>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª</h3>', 'info');
                
                const requiredFiles = [
                    'models/text_det.onnx',
                    'models/text_rec_jp.onnx',
                    'models/text_angle.onnx',
                    'models/charset_jp.txt'
                ];
                
                let allFilesExist = true;
                
                for (const filePath of requiredFiles) {
                    try {
                        const response = await fetch(`../${filePath}`);
                        const size = response.headers.get('content-length');
                        const sizeText = size ? ` (${(size / 1024).toFixed(1)}KB)` : '';
                        
                        if (response.ok) {
                            addResult(`âœ… ${filePath}${sizeText}`, 'success');
                        } else {
                            addResult(`âŒ ${filePath} - HTTP ${response.status}`, 'error');
                            allFilesExist = false;
                        }
                    } catch (error) {
                        addResult(`âŒ ${filePath} - ${error.message}`, 'error');
                        allFilesExist = false;
                    }
                }
                
                // Test 2: Validate charset file content
                addResult('<h3>ğŸ“ æ–‡å­—ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼</h3>', 'info');
                
                try {
                    const response = await fetch('../models/charset_jp.txt');
                    if (response.ok) {
                        const text = await response.text();
                        const lines = text.split('\n');
                        const characters = lines.filter(line => line.trim() && !line.startsWith('#'));
                        
                        addResult(`âœ… æ–‡å­—ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿æˆåŠŸ: ${characters.length}æ–‡å­—`, 'success');
                        
                        // Check for essential character types
                        const hasNumbers = /[0-9]/.test(text);
                        const hasHiragana = /[ã‚-ã‚“]/.test(text);
                        const hasKatakana = /[ã‚¢-ãƒ³]/.test(text);
                        const hasKanji = /[ä¸€-é¾¯]/.test(text);
                        
                        addResult(`æ•°å­—: ${hasNumbers ? 'âœ…' : 'âŒ'} | ã²ã‚‰ãŒãª: ${hasHiragana ? 'âœ…' : 'âŒ'} | ã‚«ã‚¿ã‚«ãƒŠ: ${hasKatakana ? 'âœ…' : 'âŒ'} | æ¼¢å­—: ${hasKanji ? 'âœ…' : 'âŒ'}`, 
                                hasNumbers && hasHiragana && hasKatakana && hasKanji ? 'success' : 'warning');
                        
                        // Show first few characters as sample
                        const sampleChars = characters.slice(0, 20).join('');
                        addResult(`ã‚µãƒ³ãƒ—ãƒ«æ–‡å­—: <code>${sampleChars}...</code>`, 'info');
                        
                    } else {
                        addResult(`âŒ æ–‡å­—ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—`, 'error');
                    }
                } catch (error) {
                    addResult(`âŒ æ–‡å­—ã‚»ãƒƒãƒˆæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
                
                // Test 3: Check ONNX file formats (basic)
                addResult('<h3>ğŸ¤– ONNXãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ç¢ºèª</h3>', 'info');
                
                const onnxFiles = ['text_det.onnx', 'text_rec_jp.onnx', 'text_angle.onnx'];
                
                for (const filename of onnxFiles) {
                    try {
                        const response = await fetch(`../models/${filename}`);
                        if (response.ok) {
                            const buffer = await response.arrayBuffer();
                            const uint8Array = new Uint8Array(buffer);
                            const firstBytes = Array.from(uint8Array.slice(0, 20))
                                .map(b => String.fromCharCode(b))
                                .join('');
                            
                            const isPlaceholder = firstBytes.startsWith('#');
                            const size = (buffer.byteLength / 1024 / 1024).toFixed(2);
                            
                            if (isPlaceholder) {
                                addResult(`âš ï¸ ${filename} - ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ« (${size}MB)`, 'warning');
                                addResult(`ğŸ’¡ å®Ÿéš›ã®è¨“ç·´æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã«ç½®ãæ›ãˆã¦ãã ã•ã„`, 'info');
                            } else {
                                addResult(`âœ… ${filename} - ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ« (${size}MB)`, 'success');
                            }
                        }
                    } catch (error) {
                        addResult(`âŒ ${filename} ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                }
                
                // Test 4: OCR Engine compatibility check
                addResult('<h3>ğŸ”§ OCRã‚¨ãƒ³ã‚¸ãƒ³äº’æ›æ€§ç¢ºèª</h3>', 'info');
                
                try {
                    // Check if OCR engine can be instantiated with these model paths
                    const config = {
                        modelsPath: '../models/',
                        backends: ['wasm', 'webgl', 'webgpu']
                    };
                    
                    addResult(`âœ… ãƒ¢ãƒ‡ãƒ«ãƒ‘ã‚¹è¨­å®š: ${config.modelsPath}`, 'success');
                    addResult(`âœ… å¯¾å¿œãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: ${config.backends.join(', ')}`, 'success');
                    
                    // Note about actual initialization
                    addResult(`ğŸ’¡ å®Ÿéš›ã®OCRã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ã¯ã€å®Ÿãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®å¾Œã«å¯èƒ½ã«ãªã‚Šã¾ã™`, 'info');
                    
                } catch (error) {
                    addResult(`âŒ OCRã‚¨ãƒ³ã‚¸ãƒ³è¨­å®šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
                
                // Summary
                addResult('<h3>ğŸ“‹ ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼</h3>', 'info');
                
                if (allFilesExist) {
                    addResult('âœ… å…¨ã¦ã®å¿…è¦ãƒ•ã‚¡ã‚¤ãƒ«ãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã™', 'success');
                    addResult('âš ï¸ ONNXãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã§ã™ã€‚å®Ÿéš›ã®è¨“ç·´æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚', 'warning');
                    addResult('ğŸ“– è©³ç´°ãªæ‰‹é †ã¯ models/README.md ã‚’å‚ç…§ã—ã¦ãã ã•ã„', 'info');
                } else {
                    addResult('âŒ ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
                }
                
            } catch (error) {
                addResult(`âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', () => {
            addResult('ğŸ“„ ãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚ã€Œãƒ†ã‚¹ãƒˆå®Ÿè¡Œã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚', 'info');
        });
    </script>
</body>
</html>